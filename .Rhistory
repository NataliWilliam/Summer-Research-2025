vL = 0.005,   # Progression rate from latent to active TB
y1 = 0.05,    # Failed treatment leading to H/R resistance from DS
y2 = 0.05,    # Failed treatment leading to MDR from H- or R-resistant TB
z1 = 0.6,    # Success rate of DS TB treatment
z2 = 0.6,     # Success rate of H-resistant TB treatment
z3 = 0.6,     # Success rate of R-resistant TB treatment
z4 = 0.4    # Success rate of MDR TB treatment
)
E1_initial <- 1 # Latent DS
I1_initial <- 7 # Infectious DS
E2_initial <- 1 # Latent H-resistant
I2_initial <- 2 # Infectious H-resistant
E3_initial <- 1 # Latent R-resistant
I3_initial <- 5 # Infectious R-resistant
E4_initial <- 1 # Latent MDR
I4_initial <- 9 # Infectious MDR
D_initial <- 0 # Initial deaths
N_initial <- 100      # total US population
S_initial <- N_initial - (
E1_initial + I1_initial +
E2_initial + I2_initial +
E3_initial + I3_initial +
E4_initial + I4_initial +
D_initial
)
state_ini <- c(
S  = S_initial,
E1 = E1_initial,
I1 = I1_initial,
E2 = E2_initial,
I2 = I2_initial,
E3 = E3_initial,
I3 = I3_initial,
E4 = E4_initial,
I4 = I4_initial,
D  = D_initial,
N  = N_initial
)
tb_model <- function(t, state, parms) {
with(as.list(c(state, parms)), {
dS  <- (rho * N -
q*t1*lambda * S*I1/N -
q*t2*lambda * S*I2/N -
q*t3*lambda * S*I3/N -
q*t4*lambda * S*I4/N +
z1*phi1*I1 + z2*phi2*I2 + z3*phi3*I3 + z4*phi4*I4 +
(1 - l)*alpha*N -
mu0*S)
dE1 <- ((1 - p)*q*t1*lambda * S*I1/N -
vL * E1 +
(1 - y1)*(1 - z1)*phi1 * I1 +
l*alpha*(1 - r2 - r3 - r4)*N -
mu0*E1)
dI1 <- (q*t1*lambda * S*I1/N +
vL*E1 -
phi1*I1 -
mu0*I1 -
mu*I1)
dE2 <- ((1 - p)*q*t2*lambda * S*I2/N -
vL * E2 +
(1 - y2)*(1 - z2)*phi2 * I2 +
gamma*(1 - z1)*y1*phi1 * I1 +
l*alpha*r2*N -
mu0*E2)
dI2 <- (q*t2*lambda * S*I2/N +
vL*E2 -
phi2*I2 -
mu0*I2 -
mu*I2)
dE3 <- ((1 - p)*q*t3*lambda * S*I3/N -
vL * E3 +
(1 - y2)*(1 - z3)*phi3 * I3 +
(1 - gamma)*(1 - z1)*y1*phi1 * I1 +
l*alpha*r3*N -
mu0*E3)
dI3 <- (q*t3*lambda * S*I3/N +
vL*E3 -
phi3*I3 -
mu0*I3 -
mu*I3)
dE4 <- ((1 - p)*q*t4*lambda * S*I4/N -
vL * E4 +
(1 - z2)*y2*phi2 * I2 +
(1 - z3)*y2*phi3 * I3 +
l*alpha*r4*N -
mu0*E4)
dI4 <- (q*t4*lambda * S*I4/N +
vL*E4 -
phi4*I4 -
mu0*I4 -
mu*I4)
dD  <- (mu * (I1 + I2 + I3 + I4))
dN  <- (rho*N +
alpha*N -
mu*(I1 + I2 + I3 + I4) -
mu0*N)
list(c(dS, dE1, dI1, dE2, dI2, dE3, dI3, dE4, dI4, dD, dN))
})
}
t = seq(0, 50, 0.01)
out <- ode(
y = state_ini,
times = t,
func = tb_model,
parms = parms
)
head(out)
# plot
tb_long2 <- as.data.frame(out) %>%
pivot_longer(-time, names_to="Compartment", values_to="Count")
ggplot(tb_long2, aes(time, Count, color=Compartment)) +
geom_line() +
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyr)
library(deSolve)
#parameter setup
CDCActiveTotal <- c(25102, 24206, 22726, 21210, 19751, 18286, 17499, 16308, 15945, 15055, 14835, 14499, 14063, 13728, 13282, 12895, 11523, 11161, 10510, 9941, 9565) #CDC Reported Tuberculosis 2013 - Table 2
ActiveCasesTotal <- CDCActiveTotal/1000000 #Calculates total active infections from the CDC data
CDCTBDeaths <- c(1631, 1631+1478, 1631+1478+1336, 1631+1478+1336+1202, 1631+1478+1336+1202+1166, 1631+1478+1336+1202+1166+1112, 1631+1478+1336+1202+1166+1112+930, 1631+1478+1336+1202+1166+1112+930+776, 1631+1478+1336+1202+1166+1112+930+776+764, 1631+1478+1336+1202+1166+1112+930+776+764+784, 1631+1478+1336+1202+1166+1112+930+776+764+784+711, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510+555) #CDC Reported Tuberculosis 2013 - Table 1
TotalDeaths <- CDCTBDeaths/1000000
CDCTBDeathsNC <- c(1631, 1478, 1336, 1202, 1166, 1112, 930, 776, 764, 784, 711, 662, 648, 644, 554, 590, 529, 569, 536, 510, 555) #CDC Reported Tuberculosis 2013 - Table 1
DeathsNC <- CDCTBDeathsNC/1000000
CDCActiveHR <- c(1534, 1543, 1350, 1284, 1195, 1120, 999, 981, 897, 912, 903, 872, 842, 845, 798, 835, 762, 699, 753, 683, 668) #CDC Reported Tuberculosis 2013 - Table 8
ActiveCasesHR <- CDCActiveHR/1000000
CDCActiveMDR <- c(484, 431, 327, 250, 201, 155, 157, 146, 151, 158, 119, 128, 125, 124, 124, 107, 114, 105, 127, 86, 96) #CDC Reported Tuberculosis 2013 - Table 9
ActiveCasesMDR <- CDCActiveMDR/1000000
#Set up the parameters
alpha1 <- 0.105652248 #proportion of initial LTBI cases that are H-resistent
alpha2 <- 0.131520202 #proportion of initial LTBI cases that are R-resistent
alpha3 <- 0.070481149 #proportion of initial LTBI cases that are MDR
alpha <- 0.00425 #immigration rate
beta <- 0.9765406 #proportion of initial active cases that are DS
gamma <- 0.524266165 #proportion of H-resistance acquisition cases
iota <- 0.000562594 #proportion of immigrants that have LTBI
#lamda <- 15 #effective contact rate
mu <- 0.039057410 #TB mortality rate
mu0 <- 0.013 #mortality rate unrelated to TB
p <- 0.2922095 #proportion of exogenous infections that are acute
phi1 <- 0.7348457 #rate of end of treatment
phi2 <- 0.7545017 #rate of end of treatment(H-resistent)
phi3 <- 0.7938928 #rate of end of treatment (R-resistent)
phi4 <- 0.3311735 #rate of end of treatment (MDR)
ql <- 29.613758
r2 <- 0.175348553 #proportion of immigrant H-resistent LTBI cases
r3 <- 0.104873813 #proportion of immigrant R-resistent LTBI cases
r4 <- 0.181558845 #proportion of immigrant MDR LTBI cases
rho <- 0.0179 #US birth rate
t1 <- 0.083729561 #proportion of treatment time when individuals are infectious (DS)
t2 <- 0.081051151 #proportion of treatment time when individuals are infectious (H-resistent)
t3 <- 0.06638698 #proportion of treatment time when individuals are infectious (R-resistent)
t4 <- 0.004869436 #proportion of treatment time when individuals are infectious (MDR)
vL <- 0.000098600 #progression rate from latent to active infection
y1 <- 0.251006296 #proportion of failed treatments for DS TB that result in H- or R- resistance
y2 <- 0.492070759 #proportion of failed treatments for H- or R-resistant TB that result in MDR
z1 <- 0.8689962 #proportion of treatment courses for DS TB that are successful
z2 <- 0.5278056 #proportion of treatment courses for H-resistent TB that are successful
z3 <- 0.7935086 #proportion of treatment courses for R-resistent TB that are successful
z4 <- 0.4461324 #proportion of treatment courses for MDR TB that are successful
deltaT <- 0.1 #The length of each time step (in years)
finalYr <- 57 #In years - We only have data from the CDC through 2013
totT <- finalYr/deltaT #Time steps
cutoffYr <- 8/deltaT
generateResults <- function(mres) {
with(as.list(parms), {
Susceptible <- mres$S
Exposed1 <- mres$E1
Infectious1 <- mres$I1
Exposed2 <- mres$E2
Infectious2 <- mres$I2
Exposed3 <- mres$E3
Infectious3 <- mres$I3
Exposed4 <- mres$E4
Infectious4 <- mres$I4
Dead <- mres$D
Total <- mres$S + mres$E1 + mres$I1 + mres$E2 + mres$I2 + mres$E3 + mres$I3 + mres$E4 + mres$I4
InfectiousTotal <- mres$I1 + mres$I2 + mres$I3 + mres$I4
return(data.frame(Susceptible, Exposed1, Infectious1, Exposed2, Infectious2, Exposed3, Infectious3, Exposed4, Infectious4, Total, Dead, InfectiousTotal))
})
}
#Total Population
N_initial <- 280.726081
#Initial Values
I_1_initial <- (beta*(CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1])/(mu0 + mu + phi1))/1000000 #the number of individuals actively infected with DS TB
E_1_initial <- 11.213*(1-alpha1-alpha2-alpha3) #the number of individuals latently infected with DS TB
I_2_initial <- (CDCActiveHR[1]/(mu0 + mu + phi2))/1000000 #the number of individuals actively infected with H-resistent TB
E_2_initial <- 11.213*alpha1 #the number of individuals latently infected with H-resistent TB
I_3_initial <- ((1-beta)*(CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1])/(mu0 + mu + phi3))/1000000 #the number of individuals actively infected with R-resistent TB
E_3_initial <- 11.213 * alpha2 #the number of individuals latently infected with R-resistent TB
I_4_initial <- (CDCActiveMDR[1]/(mu0 + mu + phi4))/1000000 #the number of individuals actively infected with MDR TB
E_4_initial <- 11.213*alpha3 #the number of individuals latently infected with MDR TB
D_initial <- 0 #the number of deaths caused by TB
S_initial <- N_initial - I_1_initial - E_1_initial - I_2_initial - E_2_initial - I_3_initial - E_3_initial - I_4_initial - E_4_initial - D_initial #everyone else is susceptible
#Set up the time
years <- 300
time <- seq(0, years, by = 1)
#Variable Setup
S <- numeric(length(time))
I_1 <- numeric(length(time))
E_1 <- numeric(length(time))
I_2 <- numeric(length(time))
E_2 <- numeric(length(time))
I_3 <- numeric(length(time))
E_3 <- numeric(length(time))
I_4 <- numeric(length(time))
E_4 <- numeric(length(time))
D <- numeric(length(time))
N <- numeric(length(time))
#Initial Values
S[1] <- S_initial
I_1[1] <- I_1_initial
E_1[1] <- E_1_initial
I_2[1] <- I_2_initial
E_2[1] <- E_2_initial
I_3[1] <- I_3_initial
E_3[1] <- E_3_initial
I_4[1] <- I_4_initial
E_4[1] <- E_4_initial
D[1] <- D_initial
N[1] <- N_initial
#Simulation
for(t in 1:(length(time) - 1)) {
dS <- (rho * N[t]) - (ql * t1  * ( (S[t] * I_1[t]) / N[t] ))  - (ql * t2 * ( (S[t] * I_2[t]) / N[t]) ) - (ql * t3 * ( (S[t] * I_3[t]) / N[t]) ) - (ql * t4 * ( (S[t] * I_4[t]) / N[t]) ) + ( z1 * phi1 * I_1[t] ) + ( z2 * phi2 * I_2[t] ) + ( z3 * phi3 * I_3[t] ) - (mu0 * S[t])
dE_1 <- ((1 - p) * ql * t2 * ((S[t] * I_1[t]) / N[t])) - (vL * E_1[t]) + ((1 - y1) * (1 - z1) * phi1 * I_1[t]) + (iota * alpha * (1 - r2 - r3 - r4) * N[t]) - (mu0 * E_1[t])
dI_1 <- (p * ql * t1 * ((S[t] * I_1[t]) / N[t])) + (vL * E_1[t]) - (phi1 * I_1[t]) - (mu0 * I_1[t]) - (mu * I_1[t])
dE_2 <- ((1 - p) * ql * t2 * ((S[t] * I_2[t]) / N[t])) - (vL * E_2[t]) + ((1 - y2) * (1 - z2) * phi2 * I_2[t]) + (gamma * (1 - z1) * y1 * phi1 * I_1[t]) + (iota * alpha * r2 * N[t]) - (mu0 * E_2[t])
dI_2 <- (p * ql * t2 * ((S[t] * I_2[t])/N[t])) + (vL * E_2[t]) - (phi2 * I_2[t]) - (mu0 * I_2[t]) - (mu * I_2[t])
dE_3 <- ((1 - p) * ql * t3 * ((S[t] * I_3[t])/N[t])) - (vL * E_3[t]) + ((1 - y2) * (1 - z3) * phi3 * I_3[t]) + ((1 - gamma) * (1 - z1) * y1 * phi1 * I_1[t]) + (iota * alpha * r3 * N[t]) - (mu0 * E_3[t])
dI_3 <- (p * ql * t3 * ((S[t] * I_3[t]) / N[t])) + (vL * E_3[t]) - (phi3 * I_3[t]) - (mu0 * I_3[t]) - (mu * I_3[t])
dE_4 <- ((1 - p) * ql * t4 * ((S[t] * I_4[t]) / N[t])) - (vL * E_4[t]) + ((1 - z2) * y2 * phi2 * I_2[t]) + ((1 - z3) * y2 * phi3 * I_3[t]) + ((1 - z4) * phi4 * I_4[t]) + (iota * alpha * r4 * N[t]) - (mu0 * E_4[t])
dI_4 <- (p * ql * t4 * ((S[t] * I_4[t]) / N[t])) + (vL * E_4[t]) - (phi4 * I_4[t]) - (mu0 * I_4[t]) - (mu * I_4[t])
dD <- (mu * (I_1[t] + I_2[t] + I_3[t] + I_4[t]))
dN <- (rho * N[t]) + (alpha * N[t]) - (mu * (I_1[t] + I_2[t] + I_3[t] + I_4[t])) - (mu0 * N[t])
#update values
S[t+1] <- S[t] + dS
E_1[t+1] <- E_1[t] + dE_1
I_1[t+1] <- I_1[t] + dI_1
E_2[t+1] <- E_2[t] + dE_2
I_2[t+1] <- I_2[t] + dI_2
E_3[t+1] <- E_3[t] + dE_3
I_3[t+1] <- I_3[t] + dI_3
E_4[t+1] <- E_4[t] + dE_4
I_4[t+1] <- I_4[t] + dI_4
D[t+1] <- D[t] + dD
N[t+1] <- N[t] + dN
}
table <- data.frame (Day = time, S = S, E_1 = E_1, I_1 = I_1, E_2 = E_2, I_2 = I_2, E_3 = E_3, I_3 = I_3, E_4 = E_4, I_4 = I_4, D = D, N = N)
head(table)
hill <- function(initial=cutoffYr+1, final=totT+1, dataSet=P) {
# recursive=TRUE collapses dataframe to labeled vector
initv <- c(dataSet[initial,], recursive=TRUE)
# times = data points to be calculated
times <- initial:final*deltaT
# compute master results
mres <- lsoda(initv, times, table, parms)
# mres[,-1] = mres without 1st column
dataSet[initial:final,] <- c(mres[,-1])
return(dataSet)
}
# Initial conditions
S <- E1 <- I1 <- E2 <- I2 <- E3 <- I3 <- E4 <- I4 <- D <- N <- rep(0,totT) #Sets compartment values to 0
P <- data.frame(S, E1, I1, E2, I2, E3, I3, E4, I4, D, N) #Creates a matrix of compartment values
#Total Population
P$N[1] <- 280.726081 #From census data
#LTBI
P$E1[1] <- 11.213*(1-alpha1-alpha2-alpha3) #Data from Hill
P$E2[1] <- 11.213*alpha1
P$E3[1] <- 11.213*alpha2
P$E4[1] <- 11.213*alpha3
#Active TB
P$I1[1] <- (beta*(CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1])/(mu0 + mu + phi1))/1000000
#Method from Hill; The CDC tracks H-Resistant and MDR cases.
#Those leftover are either drug-susceptible or R-resistant (scaled by b and (b-1), respectively)
P$I2[1] <- (CDCActiveHR[1]/(mu0 + mu + phi2))/1000000
P$I3[1] <- ((1-beta)*(CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1])/(mu0 + mu + phi3))/1000000
P$I4[1] <- (CDCActiveMDR[1]/(mu0 + mu + phi4))/1000000
#Susceptible Population
P$S[1] <- P$N[1] - P$E1[1] - P$I1[1] - P$E2[1] - P$I2[1] - P$E3[1] - P$I3[1] - P$E4[1] - P$I4[1]
#######################################
parms <- c(rho=rho, mu0=mu0, alpha=alpha, alpha1=alpha1, alpha2=alpha2, alpha3=alpha3, beta=beta, gamma=gamma, iota=iota, mu=mu, p=p, phi1=phi1, phi2=phi2, phi3=phi3, phi4=phi4, ql = ql , r2=r2, r3=r3, r4=r4, t1=t1, t2=t2, t3=t3, t4=t4, vL=vL,y1=y1, y2=y2, z1=z1, z2=z2, z3=z3, z4=z4)
#This 'parms' vector is redundant, but needed for some of the ODE functions
yrs <- seq(1993, 1993+finalYr, deltaT)
P <- hill(1, totT+1)
#library(readr)
setwd("~/Desktop/TBfiles")
# This algorithm contains the Genetic Algorithm along with the for loop to run 1000 times
# Original code by Ellie Mainou (Smith '17), edited by Bella Delmonte (MHC '27)
# load in necessary libraries
library(deSolve)
# set random seed for reproducability
set.seed(1234)
# time setup
deltaT <- 0.1 #The length of each time step (in years)
finalYr <- 21 #In years - We only have data from the CDC through 2013
totT <- finalYr/deltaT #Time steps
cutoffYr <- 8/deltaT
# Load CDC data
CDCActiveTotal <- c(25102, 24206, 22726, 21210, 19751, 18286, 17499, 16308, 15945, 15055, 14835, 14499, 14063, 13728, 13282, 12895, 11523, 11161, 10510, 9941, 9565)
ActiveCasesTotal <- CDCActiveTotal/1000000
CDCTBDeaths <- c(1631, 1631+1478, 1631+1478+1336, 1631+1478+1336+1202, 1631+1478+1336+1202+1166, 1631+1478+1336+1202+1166+1112, 1631+1478+1336+1202+1166+1112+930, 1631+1478+1336+1202+1166+1112+930+776, 1631+1478+1336+1202+1166+1112+930+776+764, 1631+1478+1336+1202+1166+1112+930+776+764+784, 1631+1478+1336+1202+1166+1112+930+776+764+784+711, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510+555)
TotalDeaths <- CDCTBDeaths/1000000
CDCActiveHR <- c(1534, 1543, 1350, 1284, 1195, 1120, 999, 981, 897, 912, 903, 872, 842, 845, 798, 835, 762, 699, 753, 683, 668)
ActiveCasesHR <- CDCActiveHR/1000000
CDCActiveMDR <- c(484, 431, 327, 250, 201, 155, 157, 146, 151, 158, 119, 128, 125, 124, 124, 107, 114, 105, 127, 86, 96)
ActiveCasesMDR <- CDCActiveMDR/1000000
# Constant parameters
ro = 0.0179
mu0 = 0.013
alpha = 0.00425
# parameter names
param_names <- c("a2", "a3", "a4", "b", "gamma", "l", "mu", "p",
"phi1", "phi2", "phi3", "phi4", "ql", "r2", "r3", "r4",
"t1", "t2", "t3", "t4", "vL", "y1", "y2", "z1", "z2", "z3", "z4")
# Create empty parameter vector
parameters <- vector(mode="numeric", length=27)
names(parameters) <- param_names
# Matrix of parameter ranges (row 1 min, row 2 max)
ranges <- data.frame(matrix(c(0, 0.2, 0, 0.2, 0, 0.2, 0.5, 1, 0, 1, 0, 0.3, 0, 0.5, 0, 0.3, 0.6, 0.9, 0.5, 0.9, 0.3, 0.9, 0.3, 0.5, 0, 30, 0, 0.2, 0, 0.2, 0, 0.2, 0, 0.1, 0, 0.1, 0, 0.1, 0, 0.1, 0, 0.01, 0, 1, 0, 1, 0.6, 0.9, 0.5, 0.9, 0.5, 0.9, 0.1, 0.8),nrow=2, ncol=length(parameters)))
names(ranges) <- param_names
# Create a 900x27 matrix to contain the first generation
FirstGeneration<-data.frame(matrix(NA, nrow=900, ncol=27))
colnames(FirstGeneration) <- param_names
# Set the number of GA runs
trials=1
# Initialize matrix that contains convergence individuals (the best individual from each trial)
AllData<-data.frame(matrix(NA, nrow=trials, ncol=28))
# run the Genetic algorithm for the specified number of trials
for (a in 1:trials){
# Find 900 random values for each parameter (from within their specified ranges) and store to FirstGeneration
for (i in 1:27){
FirstGeneration[ , i] <- runif(900, ranges[1,i], ranges[2,i])
}
# Define helper functions
# Simulates the above ODE system over time
hill <- function(initial = cutoffYr + 1, final = totT + 1, dataSet = P, parms, pdot_fn) {
initv <- c(dataSet[initial, ], recursive = TRUE)
times <- initial:final * deltaT
mres <- lsoda(initv, times, pdot_fn, parms)
dataSet[initial:final, ] <- c(mres[, -1])
return(dataSet)
}
# Generates results from the matrix of results
generateResults <- function(mres, parameters) {
with(as.list(parameters), {
Susceptible <- mres$S
Exposed1 <- mres$E1
Infectious1 <- mres$I1
Exposed2 <- mres$E2
Infectious2 <- mres$I2
Exposed3 <- mres$E3
Infectious3 <- mres$I3
Exposed4 <- mres$E4
Infectious4 <- mres$I4
Dead <- mres$D
Total <- mres$S + mres$E1 + mres$I1 + mres$E2 + mres$I2 + mres$E3 + mres$I3 + mres$E4 + mres$I4
InfectiousTotal <- mres$I1 + mres$I2 + mres$I3 + mres$I4
return(data.frame(Susceptible, Exposed1, Infectious1, Exposed2, Infectious2, Exposed3, Infectious3, Exposed4, Infectious4, Total, Dead, InfectiousTotal))
})
}
# fitness function definition
# input: 1 individual set of parameters
evaluate_individual <- function(indiv) {
parameters <- as.numeric(indiv)
names(parameters) <- param_names
a2 <- parameters["a2"]; a3 <- parameters["a3"]; a4 <- parameters["a4"]
b <- parameters["b"]; gamma <- parameters["gamma"]; l <- parameters["l"]
mu <- parameters["mu"]; p <- parameters["p"]
phi1 <- parameters["phi1"]; phi2 <- parameters["phi2"]
phi3 <- parameters["phi3"]; phi4 <- parameters["phi4"]
ql <- parameters["ql"]; r2 <- parameters["r2"]; r3 <- parameters["r3"]; r4 <- parameters["r4"]
t1 <- parameters["t1"]; t2 <- parameters["t2"]; t3 <- parameters["t3"]; t4 <- parameters["t4"]
vL <- parameters["vL"]; y1 <- parameters["y1"]; y2 <- parameters["y2"]
z1 <- parameters["z1"]; z2 <- parameters["z2"]; z3 <- parameters["z3"]; z4 <- parameters["z4"]
# Initialize compartments
S <- E1 <- I1 <- E2 <- I2 <- E3 <- I3 <- E4 <- I4 <- D <- N <- rep(0, totT)
P <- data.frame(S, E1, I1, E2, I2, E3, I3, E4, I4, D, N)
# Initial conditions
P$N[1] <- 280.726081
P$E1[1] <- 11.213 * (1 - a2 - a3 - a4)
P$E2[1] <- 11.213 * a2
P$E3[1] <- 11.213 * a3
P$E4[1] <- 11.213 * a4
P$I1[1] <- (b * (CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1]) / (mu0 + mu + phi1)) / 1e6
P$I2[1] <- CDCActiveHR[1] / (mu0 + mu + phi2) / 1e6
P$I3[1] <- ((1 - b) * (CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1]) / (mu0 + mu + phi3)) / 1e6
P$I4[1] <- CDCActiveMDR[1] / (mu0 + mu + phi4) / 1e6
P$S[1] <- P$N[1] - sum(P[1, -1])
parms <- c(ro=ro, mu0=mu0, alpha=alpha, a2=a2, a3=a3, a4=a4, b=b, gamma=gamma, l=l, mu=mu,
p=p, phi1=phi1, phi2=phi2, phi3=phi3, phi4=phi4, ql=ql, r2=r2, r3=r3, r4=r4,
t1=t1, t2=t2, t3=t3, t4=t4, vL=vL, y1=y1, y2=y2, z1=z1, z2=z2, z3=z3, z4=z4)
Pdot <- function(t, v, parms){
with(as.list(c(parms, v)), {
dS <- ro*N + (1-l)*alpha*N + z1*phi1*I1 + z2*phi2*I2 + z3*phi3*I3 + z4*phi4*I4 - ql*t1*S*I1/N - ql*t2*S*I2/N - ql*t3*S*I3/N - ql*t4*S*I4/N - mu0*S
dE1 <- l*alpha*(1-r2-r3-r4)*N + (1-p)*ql*t1*S*I1/N + (1-y1)*(1-z1)*phi1*I1 - vL*E1 - mu0*E1
dI1 <- p*ql*t1*S*I1/N + vL*E1 - phi1*I1 - (mu0 + mu)*I1
dE2 <- l*alpha*r2*N + (1-p)*ql*t2*S*I2/N + gamma*(1-z1)*y1*phi1*I1 + (1-y2)*(1-z2)*phi2*I2 - vL*E2 - mu0*E2
dI2 <- p*ql*t2*S*I2/N + vL*E2 - phi2*I2 - (mu0 + mu)*I2
dE3 <- l*alpha*r3*N + (1-p)*ql*t3*S*I3/N + (1-gamma)*(1-z1)*y1*phi1*I1 + (1-y2)*(1-z3)*phi3*I3 - vL*E3 - mu0*E3
dI3 <- p*ql*t3*S*I3/N + vL*E3 - phi3*I3 - (mu0+mu)*I3
dE4 <- l*alpha*r4*N + (1-p)*ql*t4*S*I4/N + y2*(1-z2)*phi2*I2 + y2*(1-z3)*phi3*I3 + (1-z4)*phi4*I4 - vL*I4 - mu0*E4
dI4 <- p*ql*t4*S*I4/N + vL*E4 - phi4*I4 - (mu0+mu)*I4
dN <- (ro+alpha)*N - mu0*N - mu*(I1 + I2 + I3 + I4)
dD <- mu*(I1 + I2 + I3 + I4)
return ( list(c(dS, dE1, dI1, dE2, dI2, dE3, dI3, dE4, dI4, dD, dN)) )
})
}
# Solve the ODEs and generate results
P <- hill(1, totT + 1, P, parms, pdot_fn = Pdot)
Results <- generateResults(P, parameters)
# Calculate error as sum of percent squared differences
percdiff1 <- percdiff2 <- percdiff3 <- percdiff4 <- 0
for (k in 2:21) {
t_idx <- (1 / deltaT) * (k - 1) + 1
pred_total <- Results[t_idx, 3] * (mu0 + mu + phi1) +
Results[t_idx, 5] * (mu0 + mu + phi2) +
Results[t_idx, 7] * (mu0 + mu + phi3) +
Results[t_idx, 9] * (mu0 + mu + phi4)
pred_hr <- Results[t_idx, 5] * (mu0 + mu + phi2)
pred_mdr <- Results[t_idx, 9] * (mu0 + mu + phi4)
pred_deaths <- Results[t_idx, 11]
percdiff1 <- percdiff1 + ((100 * (pred_total - ActiveCasesTotal[k]) / ActiveCasesTotal[k])^2)
percdiff2 <- percdiff2 + ((100 * (pred_hr - ActiveCasesHR[k]) / ActiveCasesHR[k])^2)
percdiff3 <- percdiff3 + ((100 * (pred_mdr - ActiveCasesMDR[k]) / ActiveCasesMDR[k])^2)
percdiff4 <- percdiff4 + ((100 * (pred_deaths - TotalDeaths[k]) / TotalDeaths[k])^2)
}
return(percdiff1 + percdiff2 + percdiff3 + percdiff4)
}
# PARALLELIZATION SETUP
# load R's built-in parallel package
library(parallel)
# set up cluster usingso  all but one core
# ( we leave 1 core so the computer isn't maxed and system stays responsive )
numCores <- detectCores() - 1
# start a cluster of R processes to each run on a separate core
cl <- makeCluster(numCores)
# export information to the cluster about variable and function names
clusterExport(cl,
varlist = c("param_names", "ranges", "deltaT", "totT", "cutoffYr",
"ro", "mu0", "alpha",
"CDCActiveTotal", "ActiveCasesTotal",
"CDCTBDeaths", "TotalDeaths",
"CDCActiveHR", "ActiveCasesHR",
"CDCActiveMDR", "ActiveCasesMDR",
"Pdot", "hill", "generateResults", "evaluate_individual"),
envir = environment())
# make sure each R process has deSolve installed for it
clusterEvalQ(cl, library(deSolve))
# Produce fits for the first generation
# Set the number of generations
generations=20
# Store top 30 fittest individuals from each gen (27 parameters + 1 error)
EachTrial<-data.frame(matrix(NA, nrow=30*generations, ncol=28))
# Loop through each generation
for (x in 1:generations ) {
FirstGenerationError <- parApply(cl, FirstGeneration, 1, evaluate_individual)
FirstGeneration$Error <- FirstGenerationError
FirstGenerationOrdered <- FirstGeneration[order(FirstGeneration$Error), ]
FittestFirstGeneration <- FirstGenerationOrdered[1:30, ]
# Sort the top 30 again, just in case
FittestFirstGeneration <- FittestFirstGeneration[order(FittestFirstGeneration$Error), ]
# Breed Next Generation
SecondGeneration<-data.frame(matrix(NA, nrow=900, ncol=27)) # create a 900*27 dataframe to store the next generation
colnames(SecondGeneration)<-c("a2", "a3", "a4", "b", "gamma", "l", "mu", "p", "phi1", "phi2", "phi3", "phi4", "ql", "r2", "r3", "r4", "t1", "t2", "t3", "t4", "vL", "y1", "y2", "z1", "z2", "z3", "z4") # column names for the second generation's dataframe
# idk what this part does tbh
for (i in 1:30){
for (j in 1:30){
CurrentIndividual<- 30*(i-1)+j
for (z in 1:27){
coin<-runif(1, 0, 1)
if (coin>0.5) {
SecondGeneration[CurrentIndividual, z]<- FittestFirstGeneration[i, z]
} else {SecondGeneration[CurrentIndividual, z]<- FittestFirstGeneration[j, z]}
}
}
}
# what was ellie thinking: best generation N individuals should not be mutated
# what we can do to implement this in an interpretable way: track the top 30 best fit individuals and just mutate on a subset that excludes them
# Set the mutation rate
MutationRate <- 0.3
# Define the index ranges to mutate (instead of using a for loop for each individual range, we can iterate through this list!)
mutate_ranges <- list(
10:20, 30:40, 70:80, 110:120, 130:140, 170:180, 210:220, 230:240,
270:280, 310:320, 330:340, 370:380, 410:420, 430:440, 470:480,
510:520, 530:540, 570:580, 610:620, 630:640, 670:680, 710:720,
730:740, 770:780, 810:820, 830:840, 870:880)
SecondGenerationMutated <- SecondGeneration
# Apply mutation
for (range in mutate_ranges) { # loop through each mutation range
for (i in range) { # for each number in this given mutation range
for (z in 1:27) { # for each of our 27 parameters
coin <- runif(1,0,1) # randomly generate a number between 1 and 0
if (coin < MutationRate) { # if the generated number is less than the mutation rate, mutate
# Mutated value is average of current value and new random value
SecondGenerationMutated[i, z] <- (runif(1, ranges[1, z], ranges[2, z]) + SecondGenerationMutated[i, z]) / 2
} else { # Otherwise, don't mutate, just revert it to its original value
# No mutation, revert to original
SecondGenerationMutated[i, z] <- SecondGeneration[i, z]
}
}
}
}
# CHECK: is the second generation the same as its mutated counterpart?
Check<-SecondGenerationMutated-SecondGeneration
EachTrial[(30*(x-1)+1):(30*x), ]<-FittestFirstGeneration[1:30, ]
# RESET: the mutated second gen is the new "first" generation
FirstGeneration<-SecondGenerationMutated
}
#
AllData[a, ]<-EachTrial[30*generations, ]
names(AllData) <- c("a2","a3","a4","b","gamma", "l",  "mu", "p", "phi1","phi2","phi3","phi4", "ql","r2","r3", "r4", "t1","t2","t3","t4", "vL","y1","y2","z1", "z2", "z3","z4", "Error")
}
