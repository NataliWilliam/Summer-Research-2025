```{r}

# This algorithm contains the Genetic Algorithm along with the for loop to run 1000 times

# Original code by Ellie Mainou (Smith '17), edited by Bella Delmonte (MHC '27)


# load in necessary libraries
library(deSolve)


# set random seed for reproducability
set.seed(1234)


# time setup
deltaT <- 0.1 #The length of each time step (in years) 
finalYr <- 21 #In years - We only have data from the CDC through 2013
totT <- finalYr/deltaT #Time steps
cutoffYr <- 8/deltaT


# Load CDC data
CDCActiveTotal <- c(25102, 24206, 22726, 21210, 19751, 18286, 17499, 16308, 15945, 15055, 14835, 14499, 14063, 13728, 13282, 12895, 11523, 11161, 10510, 9941, 9565)
ActiveCasesTotal <- CDCActiveTotal/1000000
CDCTBDeaths <- c(1631, 1631+1478, 1631+1478+1336, 1631+1478+1336+1202, 1631+1478+1336+1202+1166, 1631+1478+1336+1202+1166+1112, 1631+1478+1336+1202+1166+1112+930, 1631+1478+1336+1202+1166+1112+930+776, 1631+1478+1336+1202+1166+1112+930+776+764, 1631+1478+1336+1202+1166+1112+930+776+764+784, 1631+1478+1336+1202+1166+1112+930+776+764+784+711, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510, 1631+1478+1336+1202+1166+1112+930+776+764+784+711+662+648+644+554+590+529+569+536+510+555)
TotalDeaths <- CDCTBDeaths/1000000
CDCActiveHR <- c(1534, 1543, 1350, 1284, 1195, 1120, 999, 981, 897, 912, 903, 872, 842, 845, 798, 835, 762, 699, 753, 683, 668)
ActiveCasesHR <- CDCActiveHR/1000000
CDCActiveMDR <- c(484, 431, 327, 250, 201, 155, 157, 146, 151, 158, 119, 128, 125, 124, 124, 107, 114, 105, 127, 86, 96) 
ActiveCasesMDR <- CDCActiveMDR/1000000

 
# Constant parameters
ro = 0.0179
mu0 = 0.013
alpha = 0.00425 


# parameter names
param_names <- c("a2", "a3", "a4", "b", "gamma", "l", "mu", "p", 
                 "phi1", "phi2", "phi3", "phi4", "ql", "r2", "r3", "r4", 
                 "t1", "t2", "t3", "t4", "vL", "y1", "y2", "z1", "z2", "z3", "z4")


# Create empty parameter vector
parameters <- vector(mode="numeric", length=27)
names(parameters) <- param_names


# Matrix of parameter ranges (row 1 min, row 2 max)
ranges <- data.frame(matrix(c(0, 0.2, 0, 0.2, 0, 0.2, 0.5, 1, 0, 1, 0, 0.3, 0, 0.5, 0, 0.3, 0.6, 0.9, 0.5, 0.9, 0.3, 0.9, 0.3, 0.5, 0, 30, 0, 0.2, 0, 0.2, 0, 0.2, 0, 0.1, 0, 0.1, 0, 0.1, 0, 0.1, 0, 0.01, 0, 1, 0, 1, 0.6, 0.9, 0.5, 0.9, 0.5, 0.9, 0.1, 0.8),nrow=2, ncol=length(parameters)))
names(ranges) <- param_names


# Create a 900x27 matrix to contain the first generation
FirstGeneration<-data.frame(matrix(NA, nrow=900, ncol=27))


colnames(FirstGeneration) <- param_names

# Set the number of GA runs
trials=1


# Initialize matrix that contains convergence individuals (the best individual from each trial)
AllData<-data.frame(matrix(NA, nrow=trials, ncol=28))


# run the Genetic algorithm for the specified number of trials
for (a in 1:trials){

  
# Find 900 random values for each parameter (from within their specified ranges) and store to FirstGeneration
for (i in 1:27){
FirstGeneration[ , i] <- runif(900, ranges[1,i], ranges[2,i])
}
  

# Define helper functions


# Simulates the above ODE system over time

hill <- function(initial = cutoffYr + 1, final = totT + 1, dataSet = P, parms, pdot_fn) {

  initv <- c(dataSet[initial, ], recursive = TRUE)
  times <- initial:final * deltaT
  mres <- lsoda(initv, times, pdot_fn, parms)
  dataSet[initial:final, ] <- c(mres[, -1])
  return(dataSet)
}



# Generates results from the matrix of results
generateResults <- function(mres, parameters) {
  with(as.list(parameters), {
    Susceptible <- mres$S
    Exposed1 <- mres$E1
    Infectious1 <- mres$I1
    Exposed2 <- mres$E2
    Infectious2 <- mres$I2
    Exposed3 <- mres$E3
    Infectious3 <- mres$I3
    Exposed4 <- mres$E4
    Infectious4 <- mres$I4
    Dead <- mres$D
    Total <- mres$S + mres$E1 + mres$I1 + mres$E2 + mres$I2 + mres$E3 + mres$I3 + mres$E4 + mres$I4
    InfectiousTotal <- mres$I1 + mres$I2 + mres$I3 + mres$I4 
    return(data.frame(Susceptible, Exposed1, Infectious1, Exposed2, Infectious2, Exposed3, Infectious3, Exposed4, Infectious4, Total, Dead, InfectiousTotal))
  })
}

# fitness function definition
# input: 1 individual set of parameters
  Pdot <- function(t, v, parms){
  with(as.list(c(parms, v)), {
    dS <- ro*N + (1-l)*alpha*N + z1*phi1*I1 + z2*phi2*I2 + z3*phi3*I3 + z4*phi4*I4 - ql*t1*S*I1/N - ql*t2*S*I2/N - ql*t3*S*I3/N - ql*t4*S*I4/N - mu0*S
    dE1 <- l*alpha*(1-r2-r3-r4)*N + (1-p)*ql*t1*S*I1/N + (1-y1)*(1-z1)*phi1*I1 - vL*E1 - mu0*E1
    dI1 <- p*ql*t1*S*I1/N + vL*E1 - phi1*I1 - (mu0 + mu)*I1
    dE2 <- l*alpha*r2*N + (1-p)*ql*t2*S*I2/N + gamma*(1-z1)*y1*phi1*I1 + (1-y2)*(1-z2)*phi2*I2 - vL*E2 - mu0*E2
    dI2 <- p*ql*t2*S*I2/N + vL*E2 - phi2*I2 - (mu0 + mu)*I2
    dE3 <- l*alpha*r3*N + (1-p)*ql*t3*S*I3/N + (1-gamma)*(1-z1)*y1*phi1*I1 + (1-y2)*(1-z3)*phi3*I3 - vL*E3 - mu0*E3
    dI3 <- p*ql*t3*S*I3/N + vL*E3 - phi3*I3 - (mu0+mu)*I3
    dE4 <- l*alpha*r4*N + (1-p)*ql*t4*S*I4/N + y2*(1-z2)*phi2*I2 + y2*(1-z3)*phi3*I3 + (1-z4)*phi4*I4 - vL*I4 - mu0*E4
    dI4 <- p*ql*t4*S*I4/N + vL*E4 - phi4*I4 - (mu0+mu)*I4
    dN <- (ro+alpha)*N - mu0*N - mu*(I1 + I2 + I3 + I4)
    dD <- mu*(I1 + I2 + I3 + I4)
    return ( list(c(dS, dE1, dI1, dE2, dI2, dE3, dI3, dE4, dI4, dD, dN)) )
  })
    
evaluate_individual <- function(indiv) {
  parameters <- as.numeric(indiv)
  names(parameters) <- param_names
  
  a2 <- parameters["a2"]; a3 <- parameters["a3"]; a4 <- parameters["a4"]
  b <- parameters["b"]; gamma <- parameters["gamma"]; l <- parameters["l"]
  mu <- parameters["mu"]; p <- parameters["p"]
  phi1 <- parameters["phi1"]; phi2 <- parameters["phi2"]
  phi3 <- parameters["phi3"]; phi4 <- parameters["phi4"]
  ql <- parameters["ql"]; r2 <- parameters["r2"]; r3 <- parameters["r3"]; r4 <- parameters["r4"]
  t1 <- parameters["t1"]; t2 <- parameters["t2"]; t3 <- parameters["t3"]; t4 <- parameters["t4"]
  vL <- parameters["vL"]; y1 <- parameters["y1"]; y2 <- parameters["y2"]
  z1 <- parameters["z1"]; z2 <- parameters["z2"]; z3 <- parameters["z3"]; z4 <- parameters["z4"]

  # Initialize compartments
  S <- E1 <- I1 <- E2 <- I2 <- E3 <- I3 <- E4 <- I4 <- D <- N <- rep(0, totT)
  P <- data.frame(S, E1, I1, E2, I2, E3, I3, E4, I4, D, N)

  # Initial conditions
  P$N[1] <- 280.726081
  P$E1[1] <- 11.213 * (1 - a2 - a3 - a4)
  P$E2[1] <- 11.213 * a2
  P$E3[1] <- 11.213 * a3
  P$E4[1] <- 11.213 * a4
  P$I1[1] <- (b * (CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1]) / (mu0 + mu + phi1)) / 1e6
  P$I2[1] <- CDCActiveHR[1] / (mu0 + mu + phi2) / 1e6
  P$I3[1] <- ((1 - b) * (CDCActiveTotal[1] - CDCActiveHR[1] - CDCActiveMDR[1]) / (mu0 + mu + phi3)) / 1e6
  P$I4[1] <- CDCActiveMDR[1] / (mu0 + mu + phi4) / 1e6
  P$S[1] <- P$N[1] - sum(P[1, -1])

  parms <- c(ro=ro, mu0=mu0, alpha=alpha, a2=a2, a3=a3, a4=a4, b=b, gamma=gamma, l=l, mu=mu,
             p=p, phi1=phi1, phi2=phi2, phi3=phi3, phi4=phi4, ql=ql, r2=r2, r3=r3, r4=r4,
             t1=t1, t2=t2, t3=t3, t4=t4, vL=vL, y1=y1, y2=y2, z1=z1, z2=z2, z3=z3, z4=z4)

}

  # Solve the ODEs and generate results
  P <- hill(1, totT + 1, P, parms, pdot_fn = Pdot)


  Results <- generateResults(P, parameters)

  # Calculate error as sum of percent squared differences
  percdiff1 <- percdiff2 <- percdiff3 <- percdiff4 <- 0

  for (k in 2:21) {
    t_idx <- (1 / deltaT) * (k - 1) + 1

    pred_total <- Results[t_idx, 3] * (mu0 + mu + phi1) +
                  Results[t_idx, 5] * (mu0 + mu + phi2) +
                  Results[t_idx, 7] * (mu0 + mu + phi3) +
                  Results[t_idx, 9] * (mu0 + mu + phi4)

    pred_hr <- Results[t_idx, 5] * (mu0 + mu + phi2)
    pred_mdr <- Results[t_idx, 9] * (mu0 + mu + phi4)
    pred_deaths <- Results[t_idx, 11]

    percdiff1 <- percdiff1 + ((100 * (pred_total - ActiveCasesTotal[k]) / ActiveCasesTotal[k])^2)
    percdiff2 <- percdiff2 + ((100 * (pred_hr - ActiveCasesHR[k]) / ActiveCasesHR[k])^2)
    percdiff3 <- percdiff3 + ((100 * (pred_mdr - ActiveCasesMDR[k]) / ActiveCasesMDR[k])^2)
    percdiff4 <- percdiff4 + ((100 * (pred_deaths - TotalDeaths[k]) / TotalDeaths[k])^2)
  }

  return(percdiff1 + percdiff2 + percdiff3 + percdiff4)
}

  
  


# PARALLELIZATION SETUP


# load R's built-in parallel package
library(parallel)

# set up cluster usingso  all but one core 

# ( we leave 1 core so the computer isn't maxed and system stays responsive )
numCores <- detectCores() - 1 

# start a cluster of R processes to each run on a separate core
cl <- makeCluster(numCores)

# export information to the cluster about variable and function names
clusterExport(cl, 
              varlist = c("param_names", "ranges", "deltaT", "totT", "cutoffYr",
                          "ro", "mu0", "alpha",
                          "CDCActiveTotal", "ActiveCasesTotal",
                          "CDCTBDeaths", "TotalDeaths",
                          "CDCActiveHR", "ActiveCasesHR",
                          "CDCActiveMDR", "ActiveCasesMDR",
                          "Pdot", "hill", "generateResults", "evaluate_individual"),
              envir = environment())


# make sure each R process has deSolve installed for it
clusterEvalQ(cl, library(deSolve))





  
# Produce fits for the first generation

# Set the number of generations
generations=20

# Store top 30 fittest individuals from each gen (27 parameters + 1 error)
EachTrial<-data.frame(matrix(NA, nrow=30*generations, ncol=28)) 

# Loop through each generation
for (x in 1:generations ) {

FirstGenerationError <- parApply(cl, FirstGeneration, 1, evaluate_individual)
FirstGeneration$Error <- FirstGenerationError
FirstGenerationOrdered <- FirstGeneration[order(FirstGeneration$Error), ]
FittestFirstGeneration <- FirstGenerationOrdered[1:30, ]


# Sort the top 30 again, just in case
FittestFirstGeneration <- FittestFirstGeneration[order(FittestFirstGeneration$Error), ]
 
# Breed Next Generation

SecondGeneration<-data.frame(matrix(NA, nrow=900, ncol=27)) # create a 900*27 dataframe to store the next generation
colnames(SecondGeneration)<-c("a2", "a3", "a4", "b", "gamma", "l", "mu", "p", "phi1", "phi2", "phi3", "phi4", "ql", "r2", "r3", "r4", "t1", "t2", "t3", "t4", "vL", "y1", "y2", "z1", "z2", "z3", "z4") # column names for the second generation's dataframe


# idk what this part does tbh
for (i in 1:30){
    for (j in 1:30){
    CurrentIndividual<- 30*(i-1)+j
    for (z in 1:27){
    coin<-runif(1, 0, 1)
    if (coin>0.5) {
    SecondGeneration[CurrentIndividual, z]<- FittestFirstGeneration[i, z]
    } else {SecondGeneration[CurrentIndividual, z]<- FittestFirstGeneration[j, z]}
    }
    }
}


# what was ellie thinking: best generation N individuals should not be mutated
# what we can do to implement this in an interpretable way: track the top 30 best fit individuals and just mutate on a subset that excludes them

# Set the mutation rate
MutationRate <- 0.3

# Define the index ranges to mutate (instead of using a for loop for each individual range, we can iterate through this list!)
mutate_ranges <- list(
  10:20, 30:40, 70:80, 110:120, 130:140, 170:180, 210:220, 230:240,
  270:280, 310:320, 330:340, 370:380, 410:420, 430:440, 470:480,
  510:520, 530:540, 570:580, 610:620, 630:640, 670:680, 710:720,
  730:740, 770:780, 810:820, 830:840, 870:880)

SecondGenerationMutated <- SecondGeneration

# Apply mutation
for (range in mutate_ranges) { # loop through each mutation range
  for (i in range) { # for each number in this given mutation range
    for (z in 1:27) { # for each of our 27 parameters
      coin <- runif(1,0,1) # randomly generate a number between 1 and 0
      if (coin < MutationRate) { # if the generated number is less than the mutation rate, mutate
        # Mutated value is average of current value and new random value
        SecondGenerationMutated[i, z] <- (runif(1, ranges[1, z], ranges[2, z]) + SecondGenerationMutated[i, z]) / 2
      } else { # Otherwise, don't mutate, just revert it to its original value
        # No mutation, revert to original
        SecondGenerationMutated[i, z] <- SecondGeneration[i, z]
      }
    }
  }
}
  
# CHECK: is the second generation the same as its mutated counterpart?
Check<-SecondGenerationMutated-SecondGeneration
  
  EachTrial[(30*(x-1)+1):(30*x), ]<-FittestFirstGeneration[1:30, ]
  
# RESET: the mutated second gen is the new "first" generation
FirstGeneration<-SecondGenerationMutated 
}

# 
AllData[a, ]<-EachTrial[30*generations, ] 
names(AllData) <- c("a2","a3","a4","b","gamma", "l",  "mu", "p", "phi1","phi2","phi3","phi4", "ql","r2","r3", "r4", "t1","t2","t3","t4", "vL","y1","y2","z1", "z2", "z3","z4", "Error")
}

write.csv(AllData, file="AllData300Mutated1.csv")
```


```{r}

stopCluster(cl)

```


## To do:
* Update with data up to 2022
* Make this code more readable


